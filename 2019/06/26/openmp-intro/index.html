<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="OpenMP 是重要的并行计算 API。">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenMP 入门教程">
<meta property="og:url" content="http://yoursite.com/2019/06/26/openmp-intro/index.html">
<meta property="og:site_name" content="RHANQTL">
<meta property="og:description" content="OpenMP 是重要的并行计算 API。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2019/06/26/openmp-intro/Users/hanqi/AppData/Roaming/Typora/typora-user-images/1561341917319.png">
<meta property="og:image" content="http://i68.tinypic.com/24pxv2a.gif">
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f1/Fork_join.svg/1200px-Fork_join.svg.png">
<meta property="og:image" content="http://yoursite.com/2019/06/26/openmp-intro/Users/hanqi/AppData/Roaming/Typora/typora-user-images/1561346339528.png">
<meta property="og:image" content="http://yoursite.com/2019/06/26/openmp-intro/Users/hanqi/AppData/Roaming/Typora/typora-user-images/1561551626830.png">
<meta property="og:image" content="http://yoursite.com/2019/06/26/openmp-intro/Users/hanqi/AppData/Roaming/Typora/typora-user-images/1561707269759.png">
<meta property="og:image" content="http://yoursite.com/2019/06/26/openmp-intro/data-share.png">
<meta property="og:image" content="http://yoursite.com/2019/06/26/openmp-intro/Users/hanqi/AppData/Roaming/Typora/typora-user-images/1561710547846.png">
<meta property="og:image" content="http://yoursite.com/2019/06/26/openmp-intro/Users/hanqi/AppData/Roaming/Typora/typora-user-images/1561719689325.png">
<meta property="og:image" content="http://yoursite.com/2019/06/26/openmp-intro/Users/hanqi/AppData/Roaming/Typora/typora-user-images/1561720722359.png">
<meta property="og:image" content="http://yoursite.com/2019/06/26/openmp-intro/Users/hanqi/AppData/Roaming/Typora/typora-user-images/1561721041100.png">
<meta property="og:updated_time" content="2019-07-02T04:46:22.101Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OpenMP 入门教程">
<meta name="twitter:description" content="OpenMP 是重要的并行计算 API。">
<meta name="twitter:image" content="http://yoursite.com/2019/06/26/openmp-intro/Users/hanqi/AppData/Roaming/Typora/typora-user-images/1561341917319.png">

<link rel="canonical" href="http://yoursite.com/2019/06/26/openmp-intro/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>OpenMP 入门教程 | RHANQTL</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">RHANQTL</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">上下求索</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>站点地图</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/26/openmp-intro/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Han Qi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RHANQTL">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          OpenMP 入门教程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-26 20:26:39" itemprop="dateCreated datePublished" datetime="2019-06-26T20:26:39+08:00">2019-06-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-02 12:46:22" itemprop="dateModified" datetime="2019-07-02T12:46:22+08:00">2019-07-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/并行计算-Parallel-Computing/" itemprop="url" rel="index"><span itemprop="name">并行计算 (Parallel Computing)</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/并行计算-Parallel-Computing/OpenMP/" itemprop="url" rel="index"><span itemprop="name">OpenMP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>OpenMP 是重要的并行计算 API。</p>
<a id="more"></a>
<p>资源：</p>
<ul>
<li><a href="https://www.openmp.org/" target="_blank" rel="noopener">OpenMP 官网</a>（OpenMP Specification）</li>
<li><a href="https://www.youtube.com/watch?v=nE-xN4Bf8XI&amp;list=PLLX-Q6B8xqZ8n8bwjGdzBJ25X2utwnoEG" target="_blank" rel="noopener">YouTube - Intel OpenMP</a></li>
<li><a href="https://docs.microsoft.com/zh-cn/cpp/parallel/openmp/openmp-in-visual-cpp?view=vs-2019" target="_blank" rel="noopener">MSDN</a></li>
</ul>
<blockquote>
<p>MSDN：如果您在應用程式中只有一個迴圈，而它執行的時間少於 15 毫秒 (根據您電腦上的額外負荷調整)，/openmp 也許就不適當，但如果超過這個時間，倒不妨考慮使用 /openmp。</p>
</blockquote>
<p>An API that may be used to <u>explicitly</u> direct <u>multi-threaded</u>, <u>shared memory</u> parallelism. </p>
<p>SMP</p>
<p><strong>Components</strong></p>
<ul>
<li>编译器指令（Compiler Directives）</li>
<li>运行时库例程（Runtime Library Routines）</li>
<li>环境变量（Environment Variables）</li>
</ul>
<p><strong>编程模型</strong></p>
<ul>
<li>Explicit Parallelism, Thread Based Parallelism</li>
<li>共享内存</li>
<li>Fork-Join 模型<ul>
<li>主线程在需要时创建一组线程</li>
</ul>
</li>
<li>Compiler Directive Based</li>
<li>Nested Parallelism Support</li>
<li>Dynamic Threads</li>
<li>I/O</li>
<li>Memory Model </li>
</ul>
<p><img src="/2019/06/26/openmp-intro/Users\hanqi\AppData\Roaming\Typora\typora-user-images\1561341917319.png" alt="1561341917319"></p>
<p><strong>Fork-Join 模型</strong></p>
<p><img src="http://i68.tinypic.com/24pxv2a.gif" alt="1561341934887"></p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f1/Fork_join.svg/1200px-Fork_join.svg.png" alt=""></p>
<p><strong>I/O</strong></p>
<p>OpenMP specifies <u>nothing</u> about parallel I/O. This is particularly important if multiple threads attempt to write/read from the same file. It is entirely up to the programmer to insure that I/O is conducted correctly within the context of a multi-threaded program.</p>
<p><strong>OpenMP 核心语法</strong></p>
<p>使用 OpenMP 需要引入头文件 <code>omp.h</code></p>
<p>OpenMP 中大多数构件是编译器指令：</p>
<pre>
    #pragma omp <i>construct</i> <i>[clause [clause]]</i>
</pre>

<p>OpenMP 中大多数构件应用于（至多，因为允许 orphaned directive）一个“structured block”</p>
<blockquote>
<p><strong>Structured Block</strong></p>
<p>A block of one or more statements with <u>one point of entry</u> at the top and <u>one point of exit</u> at the bottom</p>
</blockquote>
<p><strong>OpenMP 线程交互</strong></p>
<ul>
<li>通过共享变量通信</li>
<li>非故意的数据共享导致竞争条件<ul>
<li>竞争条件 (Race condition)：程序的结果会随着线程调度的不同而变化</li>
<li>使用同步避免数据冲突，控制竞争条件</li>
<li>同步代价高昂，所以可以通过改变数据的访问方式最小化同步的需求</li>
</ul>
</li>
</ul>
<p><strong>线程创建：并行区 (Parallel Region)</strong></p>
<p>每个线程都会执行一遍 structured block</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> A[<span class="number">1024</span>];</span><br><span class="line">omp_set_num_threads(<span class="number">8</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> id = omp_get_thread_num();</span><br><span class="line">    foo(id, A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel num_threads(8)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意：</strong>上面的 <code>A</code> 是所有线程共享的</li>
<li>Barrier：执行完的线程会在并行区的出口点等待，直至所有的线程都完成</li>
</ul>
<h3 id="并行循环"><a href="#并行循环" class="headerlink" title="并行循环"></a>并行循环</h3><p><strong>SPMD vs. Work-sharing</strong></p>
<p>前面讲的是每个线程执行相同的任务，这里讲如何切分 pathway，让每个线程完成任务的一个子集</p>
<p><strong>循环</strong></p>
<p>通过 <code>#pragma omp for</code> 创建，不能有大括号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 不能通过编译</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp for</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (...) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 不能通过编译</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果并行区只有一个 work-sharing 的 for 循环，可以将编译器指令简写为 <code>#pragma omp parallel for</code></li>
<li><strong>注意：</strong>上面的循环计数变量 <code>i</code> 默认是各线程私有的，可以通过子句 <code>private(i)</code> 显式地声明</li>
</ul>
<p>Work-sharing constructs do not launch new threads. </p>
<p>There is no implied barrier upon entry to a work-sharing construct, however there is an implied barrier at the end of a work-sharing construct. </p>
<p><strong>Work-Sharing 限制</strong></p>
<ul>
<li><p>Work-sharing 构件必须在并行区中才能并行执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nNO PARALLEL REGION\n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; omp_get_num_threads(); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, omp_get_thread_num());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nPARALLEL REGION\n"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; omp_get_num_threads(); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, omp_get_thread_num());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<pre>
    NO PARALLEL REGION
    0
</pre>
<pre>
    PARALLEL REGION
    7
    6
    2
    0
    5
    1
    4
    3
</pre>
</li>
<li><p>Work-sharing constructs must be encountered by all members of a team or none at all </p>
</li>
<li><p>Successive work-sharing constructs must be encountered in the same order by all members of a team </p>
</li>
</ul>
<p><strong>Work-Sharing 类型</strong></p>
<p><img src="/2019/06/26/openmp-intro/Users\hanqi\AppData\Roaming\Typora\typora-user-images\1561346339528.png" alt="1561346339528"></p>
<p><strong>Working with Loops</strong></p>
<p><strong>注意：</strong>一定要使循环每次迭代是独立的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> A[MAX];</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX; i++) &#123;</span><br><span class="line">    <span class="comment">// 每次依赖上一次的结果</span></span><br><span class="line">    j += <span class="number">2</span>;</span><br><span class="line">    A[i] = big(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> A[MAX];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX; i++) &#123;</span><br><span class="line">    <span class="comment">// 独立</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">5</span> + <span class="number">2</span> * (i + <span class="number">1</span>);</span><br><span class="line">    A[i] = big(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Reduction"><a href="#Reduction" class="headerlink" title="Reduction"></a>Reduction</h4><p>用于处理共享变量的情况，基本形式：<code>reduction(op: list)</code>（<code>list</code> 中的变量必须是并行区中共享的）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> A[MAX];</span><br><span class="line"><span class="comment">// 共享变量</span></span><br><span class="line"><span class="keyword">double</span> avg = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX; i++) &#123;</span><br><span class="line">    avg += A[i];</span><br><span class="line">&#125;</span><br><span class="line">avg /= MAX;</span><br></pre></td></tr></table></figure>
<p>使用 <code>reduction</code> 子句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> A[MAX];</span><br><span class="line"><span class="comment">// 共享变量</span></span><br><span class="line"><span class="keyword">double</span> avg = <span class="number">0.0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for reduction(+: avg)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX; i++) &#123;</span><br><span class="line">    avg += A[i];</span><br><span class="line">&#125;</span><br><span class="line">avg /= MAX;</span><br></pre></td></tr></table></figure>
<p><strong>私有备份初始值</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>初始值</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>0</td>
</tr>
<tr>
<td>-</td>
<td>0</td>
</tr>
<tr>
<td>*</td>
<td>1</td>
</tr>
<tr>
<td>&amp;</td>
<td>~0（<strong>注意！</strong>）</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>^</td>
<td>0</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>1</td>
</tr>
<tr>
<td>\</td>
<td>\</td>
<td></td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p><strong>OpenMP 同步方法</strong></p>
<ul>
<li><p>高级同步</p>
<ul>
<li><p>临界区：使用 <code>#pragma omp critical</code> 创建 </p>
</li>
<li><p>原子操作：使用 <code>#pragma omp atomic</code> 创建</p>
<ul>
<li>不同于临界区，原子操作只能应用于<u>单个</u>内存位置的更新</li>
</ul>
</li>
<li><p>barrier</p>
<ul>
<li>使用 <code>#pragma omp barrier</code> 创建<ul>
<li>实际上并行区中每个 structured block（包括并行区本身）的出口点（end point）都有隐式的 barrier</li>
</ul>
</li>
<li>使用 <code>#pragma omp nowait</code> 禁用隐式的 barrier</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel shared (A, B, C) private(id)</span></span><br><span class="line">&#123;</span><br><span class="line">    id = omp_get_thread_num();</span><br><span class="line">    A[id] = big_calc1(id);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp barrier</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp for</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        C[i] = big_calc3(i, A);</span><br><span class="line">    &#125;							<span class="comment">// 隐式 barrier</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp for nowait</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        B[i] = big_calc2(C, i);</span><br><span class="line">    &#125;							<span class="comment">// 隐式 barrier 被禁用</span></span><br><span class="line">    A[id] = big_calc4(id);</span><br><span class="line">&#125;								<span class="comment">// 隐式 barrier</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ordered：使用 <code>#pragma omp ordered</code> 创建</p>
<ul>
<li><p>ordered region executes in the sequential order</p>
</li>
<li><p>注意 <code>ordered</code> 使用上比较奇怪，需要两处同时写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel private(tmp)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp for ordered reduction(+: res)</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    tmp = neat_stuff(i);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp ordered</span></span><br><span class="line">    res += consum(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>低级同步</p>
<ul>
<li><p>lock <font color="red"><strong>MORE</strong></font></p>
<ul>
<li><p>简单锁：如果未设置简单锁，那么它就是可用的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">omp_init_lock(<span class="keyword">omp_lock_t</span> *)</span><br><span class="line">omp_destroy_lock(<span class="keyword">omp_lock_t</span> *)</span><br><span class="line">omp_set_lock(<span class="keyword">omp_lock_t</span> *)</span><br><span class="line">omp_unset_lock(<span class="keyword">omp_lock_t</span> *)</span><br><span class="line">omp_test_lock(<span class="keyword">omp_lock_t</span> *)</span><br></pre></td></tr></table></figure>
</li>
<li><p>嵌套锁：如果未设置嵌套锁，或者设置了但是是被执行嵌套锁函数的线程拥有的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">omp_init_nest_lock();</span><br><span class="line">omp_destroy_nest_lock();</span><br><span class="line">omp_set_nest_lock();</span><br><span class="line">omp_unset_nest_lock();</span><br><span class="line">omp_test_nest_lock();</span><br></pre></td></tr></table></figure>
</li>
<li><p>A lock implies a memory fence (a “flush”) of all thread visible variables</p>
</li>
<li><p><strong>注意：</strong>线程总是访问锁的最近一份拷贝，所以无需在锁变量上使用 flush</p>
</li>
</ul>
</li>
<li><p>flush</p>
</li>
</ul>
</li>
</ul>
<p><strong>执行控制</strong></p>
<ul>
<li><code>master</code> 构件：表示关联的 structured block 只由主线程执行，其他线程会将其跳过<ul>
<li>没有隐式同步</li>
</ul>
</li>
<li><code>single</code> 构件：表示关联的 structured block 只由一个线程执行<ul>
<li>隐式 barrier，可以用 <code>nowait</code> 构件禁用</li>
</ul>
</li>
</ul>
<h3 id="运行时库例程"><a href="#运行时库例程" class="headerlink" title="运行时库例程"></a>运行时库例程</h3><h4 id="执行环境函数"><a href="#执行环境函数" class="headerlink" title="执行环境函数"></a>执行环境函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">omp_set_num_threads</span><span class="params">(<span class="keyword">int</span> num_threads)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">omp_get_num_threads</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">omp_get_max_threads</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">omp_get_thread_num</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">omp_get_num_procs</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">omp_in_parallel</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">omp_set_dynamic</span><span class="params">(<span class="keyword">int</span> dynamic_threads)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">omp_get_dynamic</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>示例：使用固定数目的线程</strong></p>
<p>步骤：</p>
<ol>
<li>禁用动态调整</li>
<li>设置线程数</li>
<li>保存线程数</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num_threads;</span><br><span class="line">    omp_set_dynamic(<span class="number">0</span>);</span><br><span class="line">    omp_set_num_threads(omp_num_procs());</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id = omp_get_thread_num();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> omp single</span></span><br><span class="line">        num_threads = omp_get_num_threads();</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p><img src="/2019/06/26/openmp-intro/Users\hanqi\AppData\Roaming\Typora\typora-user-images\1561551626830.png" alt="1561551626830"></p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>设置默认线程数：<code>OMP_NUM_THREADS &lt;int_literal&gt;</code></p>
<p>控制 OpenMP for 循环调度：<code>OMP_SCHEDULE &lt;schedule [, chunk_size]&gt;</code></p>
<p><strong>OpenMP 2.5 和 3.0 的差异</strong></p>
<p><img src="/2019/06/26/openmp-intro/Users\hanqi\AppData\Roaming\Typora\typora-user-images\1561707269759.png" alt="1561707269759"></p>
<h3 id="数据环境-Data-Environment"><a href="#数据环境-Data-Environment" class="headerlink" title="数据环境 (Data Environment)"></a>数据环境 (Data Environment)</h3><p><strong>默认存储属性</strong></p>
<ul>
<li><p>共享内存编程模型：大多数变量默认是共享的</p>
</li>
<li><p>全局变量在线程间共享，包括</p>
<ul>
<li>全局变量（File scope variable）和静态变量</li>
<li>动态分配的内存</li>
</ul>
</li>
<li><p>不共享的情况</p>
<ul>
<li>从并行区调用的函数的栈变量是线程私有的</li>
<li>语句块中的自动变量 (Automatic variable) 是私有的</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件 a.c</span></span><br><span class="line"><span class="keyword">double</span> A[<span class="number">10</span>];					<span class="comment">// 全局变量，共享</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index[<span class="number">10</span>];				<span class="comment">// 虽然是栈变量，但并不是</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel		<span class="comment">// 从并行区调用的函数的栈变量，共享</span></span></span><br><span class="line">    work(index);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, index[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件 b.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> A[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> *index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> temp[<span class="number">10</span>];			<span class="comment">// 从并行区调用的函数的栈变量，私有</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count;			<span class="comment">// static 变量，共享</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2019/06/26/openmp-intro/data-share.png">
</li>
</ul>
<p><strong>更改存储属性</strong></p>
<p>下面的子句除 <code>shared</code> 只能用于 parallel 外，其他的能用于 parallel 和 worksharing，但也<u>仅限于</u>关联的 construct，不会用于整个区域</p>
<ul>
<li><p><code>shared</code></p>
</li>
<li><p>私有</p>
<ul>
<li><p><code>private(var)</code> <font color="red"><strong>MORE: PPT pp. 66</strong></font></p>
<ul>
<li><strong>注意：</strong>如下的代码：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">danger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel private(tmp)</span></span><br><span class="line">    work();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> tmp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tmp = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 OpenMP 2.5 中，<code>tmp</code> 的值未指定，而在 OpenMP 3.0 中，不同的实现可能有不同的行为：或者引用原变量，或者引用原变量的一份拷贝</p>
</li>
<li><p><code>firstprivate</code>：<code>private</code> 的特殊情况，用主线程的值初始化每个私有拷贝</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useless</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for firstprivate(tmp)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 每个线程都有初值为 0 的 tmp 的拷贝</span></span><br><span class="line">        tmp += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// OpenMP 2.5 中未定，OpenMP 3.0 中是 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>lastprivate</code>：将私有变量最后一次迭代（在下面就是 <code>i = 999</code> 时，不管这一次迭代是什么时候出现的）的值赋给全局变量 MORE</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">closer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for firstprivate(tmp) lastprivate(tmp)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 每个线程都有初值为 0 的 tmp 的拷贝</span></span><br><span class="line">        tmp += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for firstprivate(sum) lastprivate(sum)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"sum = %d (ID = %d)\n"</span>, sum, omp_get_thread_num());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Using firstprivate &amp; lastprivate:\n  sum = %d\n"</span>, sum);</span><br></pre></td></tr></table></figure>
<p>输出结果可能是：</p>
<pre>
sum = 0 (ID = 0)
sum = 1 (ID = 0)
sum = 3 (ID = 0)
sum = 6 (ID = 2)
sum = 13 (ID = 2)
sum = 8 (ID = 3)
sum = 17 (ID = 3)
sum = 3 (ID = 1)
sum = 7 (ID = 1)
sum = 12 (ID = 1)
Using firstprivate & lastprivate:
  sum = 17
</pre>

<p>多次运行，其中 sum 最终值为 17 不会改变，但是每次 sum = 17 (ID = 3) 出现的位置不一定</p>
</li>
<li><p>示例</p>
<p><img src="/2019/06/26/openmp-intro/Users\hanqi\AppData\Roaming\Typora\typora-user-images\1561710547846.png" alt="1561710547846"></p>
<ul>
<li>A 是共享的，B 和 C 都是线程私有的，其中，线程私有拷贝的 B 的初值不确定，线程私有拷贝的 C 的初值为 1</li>
<li>离开并行区后，B 的值是未定义的<ul>
<li>如果是 OpenMP 2.5，则 C 的值都是未定义的</li>
<li>如果是 OpenMP 3.0，则 C 的值为 1</li>
</ul>
</li>
</ul>
</li>
<li><p>修改默认存储属性：<code>default (shared|none)</code></p>
<ul>
<li>默认 shared（例外是 task 构造）</li>
<li>如果设置成 None，则必须要显式地指明每个变量的存储属性</li>
</ul>
</li>
</ul>
<h3 id="Section"><a href="#Section" class="headerlink" title="Section"></a>Section</h3><p>回看 Fork-Join 模型的图</p>
<p>使用 <code>sections</code> 和 <code>section</code> 创建</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp sections</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> omp section</span></span><br><span class="line">        x_calculation();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> omp section</span></span><br><span class="line">        y_calculation();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> omp section</span></span><br><span class="line">        z_calculation();</span><br><span class="line">    &#125;						<span class="comment">// implicit barrier</span></span><br><span class="line">&#125;							<span class="comment">// implicit barrier</span></span><br></pre></td></tr></table></figure>
<h3 id="Loop-Work-Sharing-Construct：Schedule"><a href="#Loop-Work-Sharing-Construct：Schedule" class="headerlink" title="Loop Work-Sharing Construct：Schedule"></a>Loop Work-Sharing Construct：Schedule</h3><p>Schedule 用于控制循环迭代到线程之间的映射</p>
<p>(在 GCC 8.1.0 中，默认是 dynamic)</p>
<ul>
<li><code>schedule(static[, chunk])</code>：每个线程拿到 <code>chunk</code> 大小的迭代<ul>
<li>默认情况下？</li>
</ul>
</li>
<li><code>schedule(dynamic[, chunk])</code>：每个线程从队列中取 <code>chunk</code> 大小的迭代块直到所有的迭代都被处理完<ul>
<li>默认？</li>
</ul>
</li>
<li><code>schedule(guided[, chunk])</code>：线程动态地获取迭代块，块大小的初始值比较大，并且随着计算收缩至 <code>chunk</code> 大小<ul>
<li>默认？</li>
</ul>
</li>
<li><code>schedule(runtime)</code>：从环境变量 OMP_SCHEDULE 或者 OpenMP 3.0 运行时库中获取 schedule 和 chunk size</li>
</ul>
<blockquote>
<p><code>static</code> schedule means that iterations blocks are mapped statically to the execution threads in a <u>round-robin</u> fashion. The nice thing with static scheduling is that OpenMP run-time guarantees that if you have two separate loops with the same number of iterations and execute them with the same number of threads using static scheduling, then each thread will receive exactly the same iteration range(s) in both parallel regions. This is quite important on NUMA systems: if you touch some memory in the first loop, it will reside on the NUMA node where the executing thread was. Then in the second loop the same thread could access the same memory location faster since it will reside on the same NUMA node.</p>
<p><strong>Example:</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">&gt;     omp_set_dynamic(<span class="number">0</span>);</span><br><span class="line">&gt;     omp_set_num_threads(<span class="number">4</span>);</span><br><span class="line">&gt;     <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">&gt;     &#123;</span><br><span class="line">&gt;         <span class="meta">#<span class="meta-keyword">pragma</span> omp for schedule(static, 1)</span></span><br><span class="line">&gt;         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">&gt;             <span class="built_in">printf</span>(<span class="string">"%d (ID = %d)\n"</span>, i, omp_get_thread_num());</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>输出：</p>
<pre>
    $ ./a.exe | sort
    00 (ID = 0)
    01 (ID = 1)
    02 (ID = 2)
    03 (ID = 3)
    04 (ID = 0)
    05 (ID = 1)
    06 (ID = 2)
    07 (ID = 3)
</pre>

<p>如果没有指定 chunk_size，那么（猜测）会这样计算：比如有 34 次迭代，4 个线程，首先 34 / 4 = 8，每个线程先分 8 个迭代，然后还剩 2 个，就给前两个线程平均分。注意的是最终的结果并不同于这里的逻辑，而是 9+9+8+8.</p>
<hr>
<p><code>dynamic</code> scheduling works on a “first come, first served” basis. Two runs with the same number of threads might (and most likely would) produce completely different “iteration space” -&gt; “threads” mappings as one can easily verify:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">&gt;   <span class="keyword">int</span> i;</span><br><span class="line">&gt;   <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel num_threads(8)</span></span><br><span class="line">&gt;   &#123;</span><br><span class="line">&gt;     <span class="meta">#<span class="meta-keyword">pragma</span> omp for schedule(dynamic,1)</span></span><br><span class="line">&gt;     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">&gt;       <span class="built_in">printf</span>(<span class="string">"[1] iter %0d, tid %0d\n"</span>, i, omp_get_thread_num());</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="meta">#<span class="meta-keyword">pragma</span> omp for schedule(dynamic,1)</span></span><br><span class="line">&gt;     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">&gt;       <span class="built_in">printf</span>(<span class="string">"[2] iter %0d, tid %0d\n"</span>, i, omp_get_thread_num());</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<pre>

</pre>



</blockquote>
<p><img src="/2019/06/26/openmp-intro/Users\hanqi\AppData\Roaming\Typora\typora-user-images\1561719689325.png" alt="1561719689325"></p>
<h3 id="Memory-Model"><a href="#Memory-Model" class="headerlink" title="Memory Model"></a>Memory Model</h3><p><img src="/2019/06/26/openmp-intro/Users\hanqi\AppData\Roaming\Typora\typora-user-images\1561720722359.png" alt="1561720722359"></p>
<p><img src="/2019/06/26/openmp-intro/Users\hanqi\AppData\Roaming\Typora\typora-user-images\1561721041100.png" alt="1561721041100"></p>
<h3 id="OpenMP-3-0-新特性：Task"><a href="#OpenMP-3-0-新特性：Task" class="headerlink" title="OpenMP 3.0 新特性：Task"></a>OpenMP 3.0 新特性：Task</h3><p><strong>两个活动</strong></p>
<ul>
<li>packaging: each encountering thread packages a new instance of a task (code + data)</li>
<li>execution: some thread in the team executes the task at some later time</li>
</ul>
<ul>
<li>Task 通常默认是 firstprivate</li>
</ul>
<p><strong>threadprivate</strong></p>
<ul>
<li>将全局变量设为线程私有</li>
<li>不同于 private<ul>
<li>使用 private 会将全局变量屏蔽</li>
<li>使用 threadprivate 能够保留全局域的访问</li>
</ul>
</li>
<li>threadprivate 变量可以使用 copyin 或者在定义时（使用语言定义的初始化行为）初始化</li>
</ul>
<p><strong>copyin</strong></p>
<p><strong>copyprivate</strong></p>
<font color="red">MORE</font>

<h3 id="嵌套并行区"><a href="#嵌套并行区" class="headerlink" title="嵌套并行区"></a>嵌套并行区</h3><p>在 OpenMP 3.0 中，增强了对嵌套并行区的支持。允许在并行区中使用 <code>omp_set_num_threads</code> 设置下一级的线程数</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/06/20/tensorflow-intro/" rel="prev" title="TensorFlow 入门">
      <i class="fa fa-chevron-left"></i> TensorFlow 入门
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/06/27/c-timing/" rel="next" title="C/C++ 中的计时函数">
      C/C++ 中的计时函数 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#并行循环"><span class="nav-text">并行循环</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Reduction"><span class="nav-text">Reduction</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步"><span class="nav-text">同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时库例程"><span class="nav-text">运行时库例程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#执行环境函数"><span class="nav-text">执行环境函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#环境变量"><span class="nav-text">环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据环境-Data-Environment"><span class="nav-text">数据环境 (Data Environment)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Section"><span class="nav-text">Section</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Loop-Work-Sharing-Construct：Schedule"><span class="nav-text">Loop Work-Sharing Construct：Schedule</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Memory-Model"><span class="nav-text">Memory Model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenMP-3-0-新特性：Task"><span class="nav-text">OpenMP 3.0 新特性：Task</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#嵌套并行区"><span class="nav-text">嵌套并行区</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Han Qi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">277</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">76</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Han Qi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
